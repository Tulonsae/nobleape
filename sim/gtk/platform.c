/**************************************************************** platform.c ============================================================= Copyright 1996-2013 Tom Barbalet. All rights reserved. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. This software and Noble Ape are a continuing work of Tom Barbalet, begun on 13 June 1996. No apes or cats were harmed in the writing of this software. ****************************************************************//*NOBLEMAKE DIR=""*//*NOBLEMAKE DIR="noble/"*//*NOBLEMAKE SET="noble.h"*//*NOBLEMAKE DIR=""*//*NOBLEMAKE DIR="universe/"*//*NOBLEMAKE SET="universe.h"*//*NOBLEMAKE DIR=""*//*NOBLEMAKE DIR="gui/"*//*NOBLEMAKE SET="gui.h"*//*NOBLEMAKE DIR=""*//*NOBLEMAKE DIR="gtk/"*//*NOBLEMAKE SET="platform.h"*//*NOBLEMAKE DIR=""*//*NOBLEMAKE DEL=""*//* Noble Ape includes */#include "platform.h"#include "../noble/noble.h"#include "../universe/universe.h"#include "../gui/gui.h"/*NOBLEMAKE END=""*//*NOBLEMAKE VAR=""*//* Platform GTK 2.0 */#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include <assert.h>/* Operating system includes */#include <unistd.h>#include <errno.h>#include <sys/types.h>#include <sys/stat.h>/* GTK/GDK includes */#include <gtk-2.0/gtk/gtk.h>#include <gtk-2.0/gdk/gdk.h>#include <gtk-2.0/gdk/gdkkeysyms.h>#define WND_HEIGHT_MAP         512#define WND_WIDTH_MAP          512#define WND_HEIGHT_TERRAIN     512#define WND_WIDTH_TERRAIN      512#define NUM_WINDOWS 2#define WND_TERRAIN 0#define WND_MAP 1/* Global variables */GtkUIManager *ui_manager;GdkPixbuf* pixbuf[NUM_WINDOWS];GtkWidget* window[NUM_WINDOWS];GtkWidget* drawingArea[NUM_WINDOWS];GdkRgbCmap* colorMap;unsigned char check;unsigned char* imageData[NUM_WINDOWS];unsigned char* local_buffer;unsigned int palette[256];unsigned char* tmpBuffer[2];unsigned char window_updated = 0xFF;unsigned char window_visible = 0xF;char current_file_name[256];unsigned char firedown = 0;int firecontrol = 0;int fire_x, fire_y;char xml_info[] =    "<ui> \<menubar name=\"MenuBar\">						\  <menu name=\"File\" action=\"File\">					\    <menuitem name=\"New\" action=\"New\" />				\    <menuitem name=\"Open\" action=\"Open\" />				\    <menuitem name=\"Open Script\" action=\"Open Script\" />		\    <menuitem name=\"Save\" action=\"Save\" />				\    <menuitem name=\"Save As\" action=\"Save As\" />			\    <menuitem name=\"Exit\" action=\"Exit\" />				\  </menu>								\  <menu name=\"Edit\" action=\"Edit\">					\    <menuitem name=\"Undo\" action=\"Undo\" />				\    <menuitem name=\"Cut\" action=\"Cut\" />				\    <menuitem name=\"Copy\" action=\"Copy\" />				\    <menuitem name=\"Paste\" action=\"Paste\" />			\    <menuitem name=\"Clear\" action=\"Clear\" />			\  </menu>								\  <menu name=\"Control\" action=\"Control\">				\    <menuitem name=\"Pause\" action=\"Pause\" />			\    <menuitem name=\"Timed\" action=\"Timed\" />			\    <menuitem name=\"Previous Ape\" action=\"Previous Ape\" />		\    <menuitem name=\"Next Ape\" action=\"Next Ape\" />			\    <menuitem name=\"Clear Errors\" action=\"Clear Errors\" />		\    <menuitem name=\"Create Autoload\" action=\"Create Autoload\" />	\    <menuitem name=\"Hide Weather\" action=\"Hide Weather\" />  	\  </menu>								\  <menu name=\"Help\" action=\"Help\">					\    <menuitem name=\"About\" action=\"About\" />			\  </menu>								\</menubar>								\</ui>";/*NOBLEMAKE END=""*//* Functions */void plat_init(){    int i = 0;    unsigned short fit[256*3];    /* Let's create the palette for terrain drawing */    tmpBuffer[0] = (unsigned char*) malloc(256*256);    draw_fit(land_points, fit);    while (i < 256)    {        palette[i] = ((fit[i * 3 + 0] >> 8)<<16) +                     ((fit[i * 3 + 1] >> 8)<<8) +                     (fit[i * 3 + 2] >> 8);        ++i;    }    colorMap = gdk_rgb_cmap_new(palette, 256);    /* Now, get the location of the graphics buffers */    local_buffer = (unsigned char *) control_init(2, time(NULL));    if (io_disk_check((unsigned char *)"NobleApeAutoload.txt") == 1)    {        n_file	  tester;        tester.size = 4096;        tester.data = io_new(4096);        tester.location = 0;        (void)io_disk_read(&tester,(unsigned char *)"NobleApeAutoload.txt");        if(sim_filein(tester.data, tester.location) == 0)        {            control_init(0, 0);        }        io_free(tester.data);    }    if (io_disk_check((unsigned char *)"ApeScriptAutoload.txt") == 1)    {        n_file	  tester;        tester.size = 4096;        tester.data = io_new(4096);        tester.location = 0;        (void)io_disk_read(&tester,"ApeScriptAutoload.txt");        (void)sim_interpret(tester.data, tester.location);        io_free(tester.data);    }}void plat_title(char *nam){    char new_title[256];    strcpy(new_title, nam);    gtk_window_set_title(GTK_WINDOW(window[WND_MAP]),new_title);}static void plat_update(){    unsigned char lp = 0;    while (lp < NUM_WINDOWS)    {        GtkWidget *widget = drawingArea[lp];        switch(lp)        {        case WND_TERRAIN:            gdk_draw_indexed_image(widget->window,widget->style->fg_gc[GTK_WIDGET_STATE (widget)],0,0,WND_WIDTH_TERRAIN,WND_HEIGHT_TERRAIN,GDK_RGB_DITHER_NORMAL,(unsigned char*)TERRAINWINDOW(local_buffer),WND_WIDTH_TERRAIN,colorMap);            break;        case WND_MAP:            gdk_draw_indexed_image(widget->window,widget->style->fg_gc[GTK_WIDGET_STATE (widget)],0,0,WND_WIDTH_MAP,WND_HEIGHT_MAP,GDK_RGB_DITHER_NORMAL,(unsigned char*)VIEWWINDOW(local_buffer),WND_WIDTH_MAP,colorMap);            break;        }        lp++;    }}static unsigned char plat_ourarea(GtkWidget* area){    unsigned char lp = 0;    while (lp < NUM_WINDOWS)    {        if (area == drawingArea[lp])            return (lp + 1);        lp++;    }    return 0;}static unsigned char plat_ourwind(GtkWidget* area){    unsigned char lp = 0;    while (lp < NUM_WINDOWS)    {        if (area == window[lp])            return (lp + 1);        lp++;    }    return 0;}static void plat_message_box(char error[]){    GtkWidget* dialog;    dialog = gtk_message_dialog_new (GTK_WINDOW(window[WND_MAP]),                                     GTK_DIALOG_DESTROY_WITH_PARENT,                                     GTK_MESSAGE_ERROR,                                     GTK_BUTTONS_CLOSE,                                     error);    gtk_dialog_run (GTK_DIALOG (dialog));    gtk_widget_destroy (dialog);}static unsigned char plat_file_open(control_file_handle cfh){    GtkWidget* fDialog;    GtkFileFilter* all_filter;    GtkFileFilter* na_filter;    char *filename;    char actual_file_name[256] = {0};    char *folder;    unsigned char *buff;    int buff_len;    char error[50];    FILE *file;    struct stat stats;    int format_ok;    na_filter = gtk_file_filter_new();    all_filter = gtk_file_filter_new();    gtk_file_filter_set_name(all_filter,"All Files");    gtk_file_filter_add_pattern(all_filter,"*");    gtk_file_filter_set_name(na_filter,"NobleApe Files");    gtk_file_filter_add_pattern(na_filter,"*.nas");    fDialog = gtk_file_chooser_dialog_new("Open File", GTK_WINDOW(window[WND_MAP]), GTK_FILE_CHOOSER_ACTION_OPEN, GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT, NULL);    gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(fDialog),na_filter);    gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(fDialog),all_filter);    if (gtk_dialog_run (GTK_DIALOG (fDialog)) == GTK_RESPONSE_ACCEPT)    {        filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (fDialog));        folder = gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER (fDialog));        if (filename != NULL)        {            strcpy(current_file_name,filename);            strcpy(actual_file_name,&filename[strlen(folder)+1]);        }        else        {            return 0;        }        g_free(filename);        g_free(folder);    }    else    {        gtk_widget_destroy (fDialog);        return 0;    }    gtk_widget_destroy (fDialog);    if (stat(current_file_name,&stats) < 0)    {        strcpy(error,"Unable to get file size: ");        strcat(error, strerror(errno));        plat_message_box(error);        return 0;    }    file = fopen(current_file_name,"r");    buff_len = stats.st_size;    buff = (unsigned char*) io_new(buff_len*sizeof(unsigned char));    if (fread(buff, sizeof(unsigned char), buff_len, file) != buff_len)    {        plat_message_box("Unable to read from file!");        io_free(buff);        fclose(file);        return 0;    }    format_ok = (*cfh)(buff,buff_len);    if (format_ok == -1)    {        plat_message_box("File processing failed!");        io_free(buff);        fclose(file);        return 0;    }    io_free(buff);    fclose(file);    if (cfh == &sim_filein)    {        plat_title(actual_file_name);    }    return (format_ok == 0);}static unsigned char plat_file_save(){    unsigned long buff_len;    unsigned char* buff;    FILE* file;    buff = sim_fileout(&buff_len);    file = fopen(current_file_name,"w");    if (file == NULL)    {        plat_message_box("Unable to open file for writing!");        return 0;    }    if (fwrite(buff,sizeof(unsigned char), buff_len, file) != buff_len)    {        plat_message_box("Unable to write!");        return 0;    }    fclose(file);    io_free(buff);    return 1;}static unsigned char plat_file_save_as(){    GtkWidget* fDialog;    char *filename;    char *folder;    char actual_file_name[256] = { 0 };    size_t flen;    fDialog = gtk_file_chooser_dialog_new("Save As", GTK_WINDOW(window[WND_MAP]), GTK_FILE_CHOOSER_ACTION_SAVE, GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, GTK_STOCK_SAVE, GTK_RESPONSE_ACCEPT, NULL);    if (gtk_dialog_run (GTK_DIALOG (fDialog)) == GTK_RESPONSE_ACCEPT)    {        filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (fDialog));        folder = gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER (fDialog));        if (filename != NULL)        {            strcpy(actual_file_name,&filename[strlen(folder)+1]);            flen = strlen(filename);            if (flen < 4)            {                strcat(actual_file_name, NOBLE_APE_FILE_EXTN);                strcat(filename, NOBLE_APE_FILE_EXTN);            }            else            {                if (filename[flen - 4] != '.')                {                    strcat(actual_file_name, NOBLE_APE_FILE_EXTN);                    strcat(filename, NOBLE_APE_FILE_EXTN);                }            }            strcpy(current_file_name,filename);        }        else        {            return 0;        }        g_free(filename);        g_free(folder);    }    else    {        gtk_widget_destroy (fDialog);        return 0;    }    gtk_widget_destroy (fDialog);    plat_file_save();    plat_title(actual_file_name);    return 1;}gboolean plat_end(gpointer data){    if (io_disk_check((unsigned char *)"NobleApeAutoload.txt") == 1)    {        unsigned long		buff_len;        unsigned char * buff = sim_fileout(&buff_len);        FILE          * outputfile = fopen("NobleApeAutoload.txt","w");        fwrite(buff, buff_len, 1, outputfile);        fclose(outputfile);        io_free(buff);    }    sim_close();    gdk_rgb_cmap_free(colorMap);    free(tmpBuffer[0]);    return TRUE;}gboolean refresh(gpointer data){    while (g_main_context_iteration(NULL, FALSE));    sim_thread_console();    if (firedown != 0)    {        control_mouse((n_byte)(firedown - 1), fire_x, fire_y, firecontrol);    }    control_simulate((60*clock())/CLOCKS_PER_SEC);    plat_update();    window_updated = 0;    if (sim_thread_console_quit())    {        (void)plat_end(0L);        exit(0);    }    return TRUE;}void menu_new_callback(){    plat_title("NobleApe");    control_init(1,clock());    window_updated = 255;    gtk_widget_set_sensitive(gtk_ui_manager_get_widget(ui_manager,"ui/MenuBar/File/Save"),FALSE);}void menu_open_callback(){    if (plat_file_open(&sim_filein))    {        control_init(0, 0);        window_updated = 255;        gtk_widget_set_sensitive(gtk_ui_manager_get_widget(ui_manager,"ui/MenuBar/File/Save"),TRUE);    }}void menu_open_script_callback(){    (void)plat_file_open(&sim_interpret);    window_updated = 255;}void menu_save_callback(){    plat_file_save();    window_updated = 255;}void menu_save_as_callback(){    if (plat_file_save_as())    {        gtk_widget_set_sensitive(gtk_ui_manager_get_widget(ui_manager,"ui/MenuBar/File/Save"),TRUE);    }    window_updated = 255;}void menu_about_callback(){    control_about("GTK+");}void menu_pause_callback(){    (void)control_toggle_pause(1);}void menu_prev_callback(){    control_key(0, 2079);}void menu_next_callback(){    control_key(0, 2078);}void menu_clear_errors_callback(){    (void)draw_error(0L);}void menu_create_autoload_callback(){    if (io_disk_check((unsigned char *)"NobleApeAutoload.txt") == 0)    {        unsigned long		buff_len;        unsigned char * buff = sim_fileout(&buff_len);        FILE          * outputfile = fopen("NobleApeAutoload.txt","w");        fwrite(buff, buff_len, 1, outputfile);        fclose(outputfile);        io_free(buff);    }}void menu_hide_weather_callback(){    (void)draw_toggle_weather();}void menu_callback(){    // dummy}gboolean button_press_callback (GtkWidget *widget, GdkEventButton *event, gpointer data){    firedown = plat_ourarea(widget);    return TRUE;}gboolean button_release_callback(GtkWidget *widget, GdkEventButton *event, gpointer data){    firedown = 0;    return TRUE;}gboolean key_press_callback (GtkWidget *widget, GdkEventKey *event, gpointer data){    int windownum = plat_ourwind(widget);    unsigned short response = 0;    switch(event->keyval)    {    case GDK_Left:        response = 28;        break;    case GDK_Right:        response = 29;        break;    case GDK_Up:        response = 30;        break;    case GDK_Down:        response = 31;        break;    case GDK_Control_L:    case GDK_Control_R:        firecontrol = 1;        break;    }    if(response != 0)    {        if(firecontrol)            response |= 2048;        control_key((n_byte)(windownum - 1), response);    }    return TRUE;}gboolean key_release_callback (GtkWidget *widget, GdkEventKey *event, gpointer data){    if(event->keyval == GDK_Control_L ||            event->keyval == GDK_Control_R)    {        firecontrol = 0;    }    return TRUE;}gboolean motion_notify_callback(GtkWidget *widget, GdkEventMotion *event, gpointer data){    fire_x = event->x;    fire_y = event->y;    return TRUE;}gboolean expose_event_callback (GtkWidget *widget, GdkEventExpose *event, gpointer data){    return TRUE;}void createWindow(int num, char title[]){    window[num] = gtk_window_new (GTK_WINDOW_TOPLEVEL);    drawingArea[num] = gtk_drawing_area_new();	    gtk_window_set_title(GTK_WINDOW(window[num]), title);	    if (num == WND_TERRAIN)    {        gtk_window_set_default_size(GTK_WINDOW(window[num]), WND_WIDTH_TERRAIN, WND_HEIGHT_TERRAIN);        gtk_drawing_area_size(GTK_DRAWING_AREA(drawingArea[num]),WND_WIDTH_TERRAIN,WND_HEIGHT_TERRAIN);    }    else    {        gtk_window_set_default_size(GTK_WINDOW(window[num]), WND_WIDTH_MAP, WND_HEIGHT_MAP);        gtk_drawing_area_size(GTK_DRAWING_AREA(drawingArea[num]),WND_WIDTH_MAP, WND_HEIGHT_MAP);    }	    gtk_window_set_resizable(GTK_WINDOW(window[num]), 0);    gtk_container_add (GTK_CONTAINER(window[num]), drawingArea[num]);	    g_signal_connect (G_OBJECT (window[num]), "destroy",                      G_CALLBACK (gtk_main_quit), NULL);    g_signal_connect (G_OBJECT (drawingArea[num]), "expose_event",  G_CALLBACK (expose_event_callback), NULL);	    g_signal_connect (G_OBJECT (drawingArea[num]), "button_press_event", G_CALLBACK (button_press_callback), NULL);    g_signal_connect (G_OBJECT (drawingArea[num]), "button_release_event", G_CALLBACK (button_release_callback), NULL);    g_signal_connect (G_OBJECT (drawingArea[num]), "motion_notify_event", G_CALLBACK (motion_notify_callback), NULL);    g_signal_connect (G_OBJECT (window[num]), "key_press_event", G_CALLBACK(key_press_callback),NULL);    g_signal_connect (G_OBJECT (window[num]), "key_release_event", G_CALLBACK(key_release_callback),NULL);	    gtk_widget_set_events (drawingArea[num], GDK_EXPOSURE_MASK                           | GDK_BUTTON_PRESS_MASK                           | GDK_BUTTON_RELEASE_MASK                           | GDK_POINTER_MOTION_MASK                           | GDK_KEY_PRESS_MASK                           | GDK_KEY_RELEASE_MASK);	    gtk_window_set_gravity(GTK_WINDOW(window[num]), GDK_GRAVITY_NORTH_WEST);	    gtk_widget_show (drawingArea[num]);    gtk_widget_show (window[num]);}void createMenuWindow(int num, char title[]){    GtkWidget* main_menu;    GtkAccelGroup *accel_group;    GtkActionGroup *action_group;    GtkWidget *main_vbox;    GError *error;	    /* menu items */    GtkActionEntry items[] =    {        { "File", NULL, "File", NULL, NULL, NULL},        { "New", GTK_STOCK_NEW, "_New", "<control>N", "New World", menu_new_callback},        { "Open", GTK_STOCK_OPEN, "_Open", "<control>O", "Open World", menu_open_callback},        { "Open Script", GTK_STOCK_OPEN, "Open S_cript", "<control>R", "Open an ApeScript file", menu_open_script_callback},        { "Save", GTK_STOCK_SAVE, "_Save", "<control>S", "Save World", menu_save_callback},        { "Save As", GTK_STOCK_SAVE_AS, "Save _As", "<control>A", "Save World As...", menu_save_as_callback},        { "Exit", GTK_STOCK_QUIT, "_Exit", "<control>Q", "Leave NobleApe", gtk_main_quit},		        { "Edit", NULL, "Edit", NULL, NULL, NULL},        { "Undo", GTK_STOCK_UNDO, "_Undo", "<control>Z", "Undo", menu_callback},        { "Cut", GTK_STOCK_CUT, "C_ut", "<control>X", "Cut", menu_callback},        { "Copy", GTK_STOCK_COPY, "_Copy", "<control>C", "Copy", menu_callback},        { "Paste", GTK_STOCK_PASTE, "_Paste", "<control>V", "Paste", menu_callback},        { "Clear", GTK_STOCK_CLEAR, "C_lear", "<control>L", "Clear", menu_callback},		        { "Control", NULL, "Control", NULL, NULL, NULL},        { "Pause", GTK_STOCK_MEDIA_PAUSE, "P_ause", "<control>P", "Pause", menu_pause_callback},                { "Previous Ape", GTK_STOCK_MEDIA_PREVIOUS, "_Previous Ape", "minus", "Previous Ape", menu_prev_callback},        { "Next Ape", GTK_STOCK_MEDIA_NEXT, "_Next Ape", "plus", "Next Ape", menu_next_callback},        { "Clear Errors",         NULL,      "Clear Errors", NULL,"Clear Errors", menu_clear_errors_callback},        { "Create Autoload",         NULL,      "Create Autoload", NULL,"Create Autoload", menu_create_autoload_callback},        { "Hide Weather", NULL, "Hide Weather", NULL, "Hide Weather", menu_hide_weather_callback},        { "Help", NULL, "Help", NULL, NULL, NULL},        { "About", GTK_STOCK_ABOUT, "_About NobleApe", "<control>H", "About NobleApe", menu_about_callback}    };		    window[num] = gtk_window_new (GTK_WINDOW_TOPLEVEL);    drawingArea[num] = gtk_drawing_area_new();	    if (num == WND_TERRAIN)    {        gtk_window_set_default_size(GTK_WINDOW(window[num]), WND_WIDTH_TERRAIN, WND_HEIGHT_TERRAIN);        gtk_drawing_area_size(GTK_DRAWING_AREA(drawingArea[num]),WND_WIDTH_TERRAIN,WND_HEIGHT_TERRAIN);    }    else    {        gtk_window_set_default_size(GTK_WINDOW(window[num]), WND_WIDTH_MAP, WND_HEIGHT_MAP);        gtk_drawing_area_size(GTK_DRAWING_AREA(drawingArea[num]),WND_WIDTH_MAP, WND_HEIGHT_MAP);    }		    /* do not allow the user to resize windows */    gtk_window_set_resizable(GTK_WINDOW(window[num]), 0);	    gtk_container_add (GTK_CONTAINER(window[num]), drawingArea[num]);    main_vbox = gtk_vbox_new (FALSE, 1);    gtk_container_set_border_width (GTK_CONTAINER (main_vbox), 1);    gtk_container_add (GTK_CONTAINER (window[num]), main_vbox);	    action_group = gtk_action_group_new("MenuActions");    gtk_action_group_add_actions(action_group, items, G_N_ELEMENTS (items), window[num]);	    ui_manager = gtk_ui_manager_new();    gtk_ui_manager_insert_action_group(ui_manager, action_group, 0);	    accel_group = gtk_ui_manager_get_accel_group(ui_manager);	    gtk_window_add_accel_group (GTK_WINDOW (window[num]), accel_group);	    error = NULL;	    /* get XML menu structure from xml_info char vector */    if (!gtk_ui_manager_add_ui_from_string (ui_manager, xml_info, -1, &error))    {        g_message ("building menus failed: %s", error->message);        g_error_free (error);        exit (EXIT_FAILURE);    }	    g_signal_connect (G_OBJECT (window[num]), "destroy",G_CALLBACK(gtk_main_quit), NULL);    g_signal_connect (G_OBJECT (drawingArea[num]), "expose_event",  G_CALLBACK (expose_event_callback), NULL);		g_signal_connect (G_OBJECT (drawingArea[num]), "button_press_event", G_CALLBACK (button_press_callback), NULL);    g_signal_connect (G_OBJECT (drawingArea[num]), "button_release_event", G_CALLBACK (button_release_callback), NULL);    g_signal_connect (G_OBJECT (drawingArea[num]), "motion_notify_event", G_CALLBACK (motion_notify_callback), NULL);    g_signal_connect (G_OBJECT (window[num]), "key_press_event", G_CALLBACK(key_press_callback),NULL);    g_signal_connect (G_OBJECT (window[num]), "key_release_event", G_CALLBACK(key_release_callback),NULL);	    gtk_widget_set_events (drawingArea[num], GDK_EXPOSURE_MASK                           | GDK_BUTTON_PRESS_MASK                           | GDK_BUTTON_RELEASE_MASK                           | GDK_POINTER_MOTION_MASK                           | GDK_KEY_PRESS_MASK                           | GDK_KEY_RELEASE_MASK);	    gtk_window_set_gravity(GTK_WINDOW(window[num]), GDK_GRAVITY_NORTH_WEST);		    main_menu = gtk_ui_manager_get_widget (ui_manager, "/MenuBar");	    gtk_widget_set_events (drawingArea[num], GDK_EXPOSURE_MASK);	    gtk_box_pack_start (GTK_BOX (main_vbox), main_menu, FALSE, TRUE, 0);    gtk_box_pack_end (GTK_BOX (main_vbox), drawingArea[num], FALSE, TRUE, 0);	    gtk_widget_show_all(window[num]);	    /* "Save" option starts disabled */    gtk_widget_set_sensitive(gtk_ui_manager_get_widget(ui_manager,"ui/MenuBar/File/Save"),FALSE);}/* Main function */int main(int argc, char* argv[]){    (void)io_entry_execution(argc, argv);     plat_init();    gtk_init (&argc, &argv);    /* Create windows */    createWindow(WND_TERRAIN, "Terrain Window");    createWindow(WND_MAP, "Map Window");    /* Put each window on its correct position */    gtk_window_move(GTK_WINDOW(window[WND_MAP]),0,125);    gtk_window_move(GTK_WINDOW(window[WND_TERRAIN]),WND_WIDTH_MAP+50,125);    plat_title("NobleApe");    g_idle_add_full (G_PRIORITY_LOW, refresh, NULL, NULL);    gtk_quit_add(0,plat_end,NULL);    gtk_main();    return 0;}